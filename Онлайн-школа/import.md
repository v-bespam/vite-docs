---
date: 2024-10-03
tags:
  - Онлайн-школа
---
# ImportModule

Модуль предназначен для импорта и обновления данных.

## ImportController

В контроллере применяются следующие проверки

- ThrottlerGuard - ограничивает количество запросов от пользователя
- JWTGuard - проверят на валидность токен для доступа к методам
- SuperAdminRoleGuard - проверяет что у пользователя есть роль супер администратора

***

### Endpoints

Контроллер предоставляет следующие эндпоинты:

| Метод | URL                                 | Описание                              |
| ----- | ----------------------------------- | ------------------------------------- |
| GET   | `imports/users/`                    | Импорт пользователей                  |
| GET   | `imports/catalogs/`                 | Импорт каталогов                      |
| GET   | `imports/materials/`                | Импорт учебных материалов             |
| GET   | `imports/tests/`                    | Импорт тестов                         |
| GET   | `imports/subjects/`                 | Импорт предметов                      |
| GET   | `imports/programs/`                 | Импорт программ                       |
| GET   | `imports/sections/`                 | Импорт разделов                       |
| GET   | `imports/seo/`                      | Импорт SEO данных                     |
| GET   | `imports/video/`                    | Импорт видео                          |
| GET   | `imports/get-all-ids/:entity/`      | Получение идентификаторов сущности    |
| POST  | `imports/update-entities-slug/`     | Обновление slug                       |
| GET   | `imports/update-sections-subjects/` | Обновление разделов предметов         |
| GET   | `imports/attempts-numbers/`         | Обновление количества попыток         |
| GET   | `imports/set-lesson-sorts/`         | Обновление индексов сортировки уроков |

***

### Импорт пользователей

`GET imports/users/`

*Входные данные:* -

*Функционал:*

Работа метода разделена на несколько этапов:

1. Метод начинает с логирования сообщения о старте операции импорта.
2. Выполняет GET-запрос к URL `users/import`, ожидая получить массив данных пользователей в формате, соответствующем типу OldUser:

```json
{
  id: number;
  createdAt?: string;
  updatedAt: string;
  tatus: string;
  profileUpdatedAt: string;
  lastSignIn: string;
  pwdHash: string;
  salt: string;
  firstName: string;
  lastName: string;
  email: string | null;
  phoneNumber: string | null;
  middleName: string;
}
```
   
3. На основе идентификаторов, извлеченных из полученных данных, метод использует `getExistingById()` для проверки, какие пользователи уже существуют в базе данных.
4. Получение роли по умолчанию, которая будет назначена новым пользователям (задана в коде сервиса `defaultRole = 'student'`). В случае если роль не найдена выбрасывается исключение InternalServerErrorException с сообщением об ошибке "The default role was not found"
5. Метод применяет `getForCreate()` для определения пользователей, которые необходимо создать, и `getForUpdate()` для выявления пользователей, информацию о которых необходимо обновить.
	1. Функция `getForCreate()` создает объект в базе данных при помощи `userRepository.create`, добавляя к нему роль по умолчанию. Данные сохраняются в массив `creatingUsers`.
	2. Функция `getForUpdate()` при помощи `checkNeedUpdate` сверяет свойство `updatedAt` и проверяет нужно ли обновить информацию о пользователе. Если у пользователя не указана роль, ему назначается роль по умолчанию. Данные сохраняются в массив `updatingUsers`.
6. Массивы `creatingUsers` и `updatingUsers` объединяются в массив `usersToSave`, который будет использоваться для последующего сохранения в базе данных.
7. Метод подсчитывает количество пользователей, которые будут созданы и обновлены, фильтруя пользователей с пустыми идентификаторами.
8. Если в массиве `usersToSave` присутствуют пользователи, выполняет сохранение информации в базе данных. Перед началом выполнения операции и по окончании, в лог будет выведено сообщение с количеством создаваемых и обновляемых пользователей.

*Выходные данные:* Status: `200 OK`

Возвращает объект, содержащий количество созданных и обновленных пользователей, а также их идентификаторы.

```json
{
  created: {
    count: number;
    id: number[] | string[];
  };
  updated: {
    count: number;
    id: number[] | string[];
  };
}
```

### Импорт каталогов

`GET imports/catalogs/`

*Входные данные:* -

*Функционал:*

Работа метода разделена на несколько этапов:

1. Метод начинает с логирования сообщения о старте операции импорта
2. Метод выполняет GET-запрос к URL `materials/catalogs/import`, который должен вернуть массив данных о каталогах в формате, соответствующем типу `OldCatalog`. Данные фильтруются при помощи функции `filterData()`.
	1. Отфильтровываются результаты с не заданным параметром `catalog`
	2. Преобразовываются данные параметра `catalog` (путь каталога): двойные слеши `//` заменяются на `%2F/`, завершающий слеш `/` заменяется на `%2F`, последовательность из нескольких пробелов заменяется на один пробел.
	3. Выполняется поиск и фильтрование дубликатов: сравниваются свойства `catalog`, `type` и `status`.

```json
{
  id: number;
  createdAt?: string;
  updatedAt: string;
  type: OldCatalogType('PROGRAM', 'MATERIAL');
  status: OldCatalogStatus('ACTIVE', 'ARCHIVE');
  catalog: string;
}
```

2. На основе идентификаторов, извлеченных из полученных данных, метод использует `getExistingById()` для проверки, какие каталоги уже существуют в базе данных.
3. В массив `tree` формируется древо каталогов с разделением по типу (программы, учебные материалы) и статусы (активный, архивный)
	1. Каждый элемент массива `catalogs` обрабатывается с помощью функции `splitCatalogPath()`, которая разбивает строку пути каталога на отдельные части и извлекает имя каталога.
	2. Полученный массив каталогов сортируется по длине пути, что позволяет сначала обрабатывать корневые каталоги, а затем их дочерние элементы.
	3. Каталоги группируются по типу и статусу с использованием метода `groupCatalogs()`. Для каждого типа и статуса (например, `PROGRAM` с `ACTIVE` и `ARCHIVE`, а также `MATERIAL` с `ACTIVE` и `ARCHIVE`) выполняется фильтрация, чтобы оставить только соответствующие элементы.
	4. Для каждой группы каталогов вызывается метод `makeTree()`, который строит иерархическую структуру. Этот метод разделяет каталоги на корневые и дочерние, а затем рекурсивно добавляет дочерние элементы к соответствующим родительским каталогам.
	5. В результате возвращается массив каталогов в формате `CatalogWithPath`, который содержит иерархическую структуру с правильно установленными дочерними элементами.

```json
{
  path: string[];
  name: string;
  children: CatalogWithPath[];
}
```

4. Создается массив каталогов `catalogsForSave`, который содержит каталоги, готовые к сохранению в базе данных. В этом массиве также учитываются каталоги, которые необходимо создать и обновить.
	1. Функция `convertTree` принимает иерархическую структуру каталогов в формате `CatalogWithPath` и массив существующих каталогов, чтобы подготовить данные для сохранения в базе данных.
	2. Для каждого каталога в иерархии выполняется поиск существующего каталога в массиве `existingCatalogs` по его идентификатору.
	3. Если существующий каталог требует обновления, его идентификатор добавляется в массив `updatingIds`. Если каталог не найден, его идентификатор добавляется в массив `creatingIds`.
	4. Если у текущего каталога есть дочерние элементы, метод `convertTree` вызывается рекурсивно для обработки этих дочерних каталогов. Результаты рекурсивного вызова сохраняются в соответствующие массивы.
5. Если массив `catalogsForSave` не пуст, происходит сохранение новых и обновление существующих каталогов в базе данных. Перед началом выполнения операции и по окончании, в лог будет выведено сообщение с количеством создаваемых и обновляемых каталогов.

*Выходные данные:* Status: `200 OK`

Возвращает объект, содержащий количество созданных и обновленных каталогов, а также их идентификаторы.

```json
{
  created: {
    count: number;
    id: number[] | string[];
  };
  updated: {
    count: number;
    id: number[] | string[];
  };
}
```

### Импорт учебных материалов

`GET imports/materials/`

*Входные данные:* -

*Функционал:*

Работа метода разделена на несколько этапов:

1. Метод начинает с логирования сообщения о старте операции импорта.
2. Метод выполняет GET-запрос к URL `materials/import`, ожидая получить массив данных о материалах в формате, соответствующем типу `OldMaterial`. Данные фильтруются при помощи функции `filterData()`.
	1. Результаты группируются по идентификатору, чтобы объединить материалы с одинаковыми ID в массивы.
	2. Если в группе присутствует только один материал, он возвращается без изменений.
	3. Если в группе присутствует несколько материалов, первый материал модифицируется, чтобы изменить его тип на `OldMaterialType.ADDED_MATERIAL`.
	4. В конце отфильтровываются результаты, исключая значения, которые равны `null` или `undefined`.

```json
{
  id: number;
  createdAt?: string;
  updatedAt: string;
  name?: string;
  status: OldCatalogStatus('ACTIVE', 'ARCHIVE');
  url?: string;
  taskType?: OldTaskType('CONTROl', 'TRAINING', 'control', 'home');
  description?: string;
  catalog: string;
  documents: OldDocument[];
  textbook: OldTextbook;
  lessonMaterial: OldLessonMaterial;
}
```

3. На основе идентификаторов, извлеченных из полученных данных, метод использует `getExistingById()` для проверки, какие учебные материалы уже существуют в базе данных.
4. Метод обращается к сервису `importCatalogsService`, вызывая `getData()`, чтобы получить массив каталогов. Эти каталоги будут использоваться для сопоставления с материалами.
	1. Метод выполняет GET-запрос к URL `materials/catalogs/import`, который должен вернуть массив данных о каталогах в формате, соответствующем типу `OldCatalog`. Данные фильтруются при помощи функции `filterData()`. Соответствует шагу 2 раздела [Импорт каталогов](#Импорт каталогов)
5. На основе идентификаторов, извлеченных из полученных данных, метод использует `getExistingById()` для проверки, какие каталоги уже существуют в базе данных.
6. Создается массив `creatingMaterials`, в который сохраняется результат выполнения функции `getForCreate()` для определения материалов, которые необходимо создать.
	1. Сперва фильтруются данные на основе массива `existingMaterials`, что позволяет исключить существующие учебные материалы.
	2. Для каждого из оставшихся материалов вызывается функция `mapFields()`, которая преобразует тип учебного материала в нужный формат:
		- BOOK_ARTICLE преобразуется в TEXTBOOK
		- HOME преобразуется в HOMEWORK, если `taskType` соответствует `home`, иначе OTHER
		- CONTROL_TASK преобразуется в CONTROL_WORK, если `taskType` соответствует `control`, иначе OTHER
		- VIDEO_LESSON преобразуется в VIDEO
		- В других случаях указывается OTHER
	3. Метод определяет, к какому типу относится материал, устанавливая соответствующие флаги:
		- `isTextbook` если тип материала TEXTBOOK
		- `isTask` если тип материала HOMEWORK или CONTROL_WORK
		- `isOther` если другой
	4. Метод использует `materialRepository.create()` для создания нового объекта материала. В этот объект добавляются:
		- Поля, полученные при помощи функции `mapFields()`
		- Идентификаторы каталогов, найденный с помощью функции `findCatalogId()`, которая определяет, к какому каталогу относится материал на основе его пути и статуса.
		- Если материал относится к типу OTHER и у него есть приложения, при помощи `mapExistingUploadFields()` добавляются идентификаторы файлов для загрузки.
		- Если материал относится к типу TEXTBOOK, при помощи `mapExistingTextbookFields` проверяется соответствие существующим идентификаторам. Если у материала есть приложения, при помощи `mapExistingUploadFields()` добавляются идентификаторы файлов для загрузки.
		- Если материал относится к типам HOMEWORK или CONTROL_WORK, при помощи `mapExistingTaskFields` проверяется соответствие существующим идентификаторам. Если у материала есть приложения, при помощи `mapExistingUploadFields()` добавляются идентификаторы файлов для загрузки.
7. Создается массив `updatingMaterials`, в который сохраняется результат выполнения функции `getForUpdate()` для определения материалов, которые необходимо обновить.
	1. Сперва фильтруются данные на основе массива `existingMaterials`, при помощи функции `checkNeedUpdateAll` выявляются материалы, которые необходимо обновить.
	2. Остальные этапы работы функции соответствуют функции `getForCreate()` на шаге 6.
8. Полученные массивы `creatingMaterials` и `updatingMaterials` объединяются в один массив `materialsToSave`, который будет использоваться для последующего сохранения в базе данных.
9. Метод подсчитывает количество материалов, которые будут созданы и обновлены, фильтруя материалы с пустыми идентификаторами.
10. Если массив `materialsToSave` содержит материалы, метод выполняет их сохранение в базе данных с помощью `materialRepository.save()` партиями по 1000 штук. Перед началом и по завершении операции в лог выводится сообщение с количеством создаваемых и обновляемых материалов.

*Выходные данные:* Status: `200 OK`

Возвращает объект, содержащий количество созданных и обновленных учебных материалов, а также их идентификаторы.

```json
{
  created: {
    count: number;
    id: number[] | string[];
  };
  updated: {
    count: number;
    id: number[] | string[];
  };
}
```

### Импорт тестов

`GET imports/tests/`

*Входные данные:*

- Query параметры (ImportTestsDto):

```json
{
  type: OldQuestionType('ONE', 'CONFROMITY', 'SEVERAL', 'SHORT', 'SEQUENCE', 'SELECT_PICTURE', 'DND_WORD', 'TRUE_FALSE', 'NUMBER', 'SELECT', 'DND_OBJECT', 'OMISSIONS', 'LIKERT',);
  limit?: number;
  offset?: number;
}
```

*Функционал:*

Работа метода разделена на несколько этапов:

1. Метод начинает с логирования сообщения о старте операции импорта и вывода переданных в запросе параметров.
2. Метод выполняет HTTP GET-запрос к URL `materials/tests/import`, в соответствии с указанными Query параметрами. Ожидается получение массива данных о тестах в формате `OldTest`.

```json
{
  id: number;
  createdAt?: string;
  updatedAt: string;
  material: OldEntity & {
    name?: string;
    description?: string;
    status: ACTIVE | ARCHIVE;
    catalog: string;
  };
  type: TRAINING | CONTROL;
  image?: OldDocument;
  timeLimit?: number;
  isNeedToMixQuestions?: boolean;
  defaultPointForCorrectAnswer?: number;
  penaltyForWrongAnswer?: number;
  canUserShowTestAfterSendSuccess?: boolean;
  canUserShowCorrectAnswersAfterSendSuccess?: boolean;
  isNeedToShowsPointsWhenTestFinishedSuccess?: boolean;
  isNeedToShowsMinPointsWhenTestFinishedSuccess?: boolean;
  canUserShowReportAfterSendSuccess?: boolean;
  isNeedShowReportByGroupsSuccess?: boolean;
  canUserRepeatTestSuccess?: boolean;
  maxRepeatCountSuccess?: number;
  isNeedToShowsPointsWhenTestFinishedFail?: boolean;
  isNeedToShowsMinPointsWhenTestFinishedFail?: boolean;
  canUserShowTestAfterSendFail?: boolean;
  canUserShowCorrectAnswersAfterSendFail?: boolean;
  canUserShowReportAfterSendFail?: boolean;
  isNeedShowReportByGroupsFail?: boolean;
  canUserRepeatTestFail?: boolean;
  maxRepeatCountFail?: number;
  groupsOfQuestions: OldQuestionGroup[];
  questions: OldQuestion[];
}
```

3. На основе идентификаторов, извлеченных из полученных данных, метод использует `getExistingById()` для проверки, какие учебные материалы уже существуют в базе данных.
4. Метод обращается к сервису `importCatalogsService`, вызывая `getData()`, чтобы получить массив каталогов. Эти каталоги будут использоваться для сопоставления с тестами
	1. Метод выполняет GET-запрос к URL `materials/catalogs/import`, который должен вернуть массив данных о каталогах в формате, соответствующем типу `OldCatalog`. Данные фильтруются при помощи функции `filterData()`. Соответствует шагу 2 раздела [Импорт каталогов](#Импорт каталогов)
5. На основе идентификаторов, извлеченных из полученных данных, метод использует `getExistingById()` для проверки, какие каталоги уже существуют в базе данных.
5. Метод вызывает `getExistingOptionsId()`, чтобы получить идентификаторы существующих опций тестов, которые могут быть использованы при создании новых тестов.
6. Создается массив `creatingMaterials`, в который сохраняется результат выполнения функции `getForCreate()` для определения материалов, которые необходимо создать.
	1. Сперва фильтруются данные на основе массива `existingTests`, что позволяет исключить существующие тесты.
	2. Для каждого из оставшихся тестов вызывается функция `mapTest()`, которая преобразует тип теста в нужный формат:
		- Извлекаются группы вопросов для импортированных данных `oldGroups` и существующих `existingGroups`. Функция проходит по каждой группе и добавляет все вопросы из этих групп в массив `existingQuestions`. Это позволяет найти все существующие вопросы, которые могут быть связаны с новыми вопросами.
		- Для преобразования вопросов тестов в формат TestQuestionSettings вызывается функция `mapQuestions()`, которая также выполняет поиск уже существующих вопросов.
		- Для преобразования ответов тестов в формат TestOption вызывается функция `mapOptions()`, которая также выполняет поиск существующих ответов, создает новые и в случает, если для ответа задано изображение создает или обновляет поле `image` нового объекта.
		- Для преобразования групп вопросов тестов в формат TestQuestionGroup вызывается функция `mapQuestionGroups()`, которая также объединяет группы вопросов с существующими группами, если они есть или создает новые группы.
		- Для преобразования групп вопросов тестов в формат Material вызывается функция `mapMaterial()`, которая также выполняет поиск существующего учебного материала или создание нового, а также определяет идентификатор каталога, к которому относится материал. Дополнительно, если тест содержит изображение, функция создает или обновляет поле `logo`.
7. Создается массив `updatingMaterials`, в который сохраняется результат выполнения функции `getForUpdate()` для определения материалов, которые необходимо обновить.
	1. Сперва фильтруются данные на основе массива `existingTests`, при помощи функции `checkNeedUpdateAll` выявляются тесты, которые необходимо обновить.
	2. Остальные этапы работы функции соответствуют функции `getForCreate()` на шаге 6.
8. Полученные массивы `creatingMaterials` и `updatingMaterials` объединяются в один массив `materialsForSave`, который будет использоваться для последующего сохранения в базе данных.
9. Метод подсчитывает количество тестов, которые будут созданы и обновлены, фильтруя тесты с пустыми идентификаторами.
10. Если массив `materialsForSave` содержит тесты, метод выполняет их сохранение в базе данных с помощью `materialRepository.save()`. Перед началом и по завершении операции в лог выводится сообщение с количеством создаваемых и обновляемых тестов.

*Выходные данные:* Status: `200 OK`

Возвращает объект, содержащий количество созданных и обновленных тестов, а также их идентификаторы.

```json
{
  created: {
    count: number;
    id: number[] | string[];
  };
  updated: {
    count: number;
    id: number[] | string[];
  };
}
```

### Импорт предметов

`GET imports/subjects/`

*Входные данные:* -

*Функционал:*

Работа метода разделена на несколько этапов:

1. Метод начинает с логирования сообщения о старте операции импорта предметов.
2. Метод выполняет GET-запрос к URL `things/import`, ожидая получить массив данных о предметах в формате, соответствующем типу `OldSubject`:

```json
{
  id: number;
  createdAt?: string;
  updatedAt: string;
  name: string;
  slug?: string;
}
```

3. На основе идентификаторов, извлеченных из полученных данных, метод вызывает `getExistingById()`, чтобы определить, какие предметы уже существуют в базе данных.
4. Определение предметов для создания и обновления:
	1. Метод использует `getForCreate()`, чтобы выявить предметы, которые необходимо создать и преобразовать их к типу Subject.
	2. Затем он применяет `getForUpdate()`, чтобы определить при помощи функции `checkNeedUpdate` предметы, которые требуют обновления, а также привести их к типу Subject.
5. Полученные массивы `creatingSubjects` и `updatingSubjects` объединяются в один массив `subjectsForSave`, который будет использоваться для последующего сохранения в базе данных.
6. Метод подсчитывает количество предметов, которые будут созданы и обновлены, фильтруя предметы с пустыми идентификаторами.
7. Если массив `subjectsForSave` содержит предметы, метод выполняет их сохранение в базе данных с помощью `subjectRepository.save()`. Перед началом и по завершении операции в лог выводится сообщение с количеством создаваемых и обновляемых предметов.

*Выходные данные:* Status: `200 OK`

Возвращает объект, содержащий количество созданных и обновленных предметов, а также их идентификаторы.

```json
{
  created: {
    count: number;
    id: number[] | string[];
  };
  updated: {
    count: number;
    id: number[] | string[];
  };
}
```

### Импорт программ

`GET imports/programs/`

*Входные данные:* -

*Функционал:*

Работа метода разделена на несколько этапов:

1. Метод начинает с логирования сообщения о старте операции импорта программ.
2. Метод выполняет GET-запрос к URL `programs/import`, ожидая получить массив данных о программах в формате `OldProgram`:

```json
{
  id: number;
  createdAt?: string;
  updatedAt: string;
  class: number;
  name: string;
  status?: OldCatalogStatus;
  course?: OldProgramCourse;
  logo?: OldDocument;
  thingId: number;
  catalog: string;
  autoIndexLessons?: boolean;
  lessons: OldLesson[];
  slug?: string;
}
```

3. На основе идентификаторов, извлеченных из полученных данных, метод вызывает `getExistingById()`, чтобы определить, какие программы уже существуют в базе данных.
4. Вызывает `getExistingSections()` для выполнения запроса к базе данных и получения существующих разделов
5. Метод обращается к сервису `importMaterialsService`, вызывая `getExistingById()`, чтобы получить массив существующих материалов, которые могут быть связаны с программами.
6. Метод также обращается к сервису `importCatalogsService`,вызывая `getData()` чтобы получить массив каталогов, которые будут использоваться для сопоставления с программами.
	1. Метод выполняет GET-запрос к URL `materials/catalogs/import`, который должен вернуть массив данных о каталогах в формате, соответствующем типу `OldCatalog`. Данные фильтруются при помощи функции `filterData()`. Соответствует шагу 2 раздела [Импорт каталогов](#Импорт каталогов)
7. Метод вызывает `getExistingSubjects()`, чтобы получить список существующих предметов
8. Создается массив `creatingPrograms`, в который сохраняется результат выполнения функции `getForCreate()` для определения программ, которые необходимо создать.
	1. Сперва метод получает текущий slug и фильтруются данные на основе массива `existingPrograms`, что позволяет исключить существующие программы.
	2. Для преобразования групп вопросов тестов в формат Program вызывается функция `mapProgram()`. Если для программы было задано изображение создает или обновляет поле `logo` нового объекта.
	3. Для преобразования групп вопросов тестов в формат Lesson вызывается функция `mapLessons()`, которая также сопоставляет существующие уроки и учебные материалы. Если для урока было задано изображение создает или обновляет поле `logo` нового объекта. Увеличивается на 1 значение поля `sortIndex`, выполняется поиск раздела и проверка уникальности slug и идентификатора.
9. Создается массив `updatingPrograms`, в который сохраняется результат выполнения функции `getForUpdate()` для определения программ, которые необходимо создать.
	1. Сперва метод получает текущий slug и фильтруются данные на основе массива `existingPrograms`, при помощи функции `checkNeedUpdateAll` выявляются тесты, которые необходимо обновить.
	2. Остальные этапы работы функции соответствуют функции `getForCreate()` на шаге 8.
10. Полученные массивы `creatingPrograms` и `updatingPrograms` объединяются в один массив `programsToSave`, который будет использоваться для последующего сохранения в базе данных.
11. Метод подсчитывает количество программ, которые будут созданы и обновлены, фильтруя программы с пустыми идентификаторами.
12. Если массив `programsToSave` содержит программы, метод выполняет их сохранение в базе данных с помощью `programRepository.save()`. Перед началом и по завершении операции в лог выводится сообщение с количеством создаваемых и обновляемых программ.

*Выходные данные:* Status: `200 OK`

Возвращает объект, содержащий количество созданных и обновленных программ, а также их идентификаторы.

```json
{
  created: {
    count: number;
    id: number[] | string[];
  };
  updated: {
    count: number;
    id: number[] | string[];
  };
}
```

### Импорт разделов

`GET imports/sections/`

*Входные данные:* -

*Функционал:*

Работа метода разделена на несколько этапов:

1. Метод начинает с логирования сообщения о старте операции импорта разделов.
2. Метод выполняет GET-запрос к URL `lessons/sections/import`, ожидая получить массив данных о разделах в формате, соответствующем типу `OldSection`, а также фильтрует полученные данные оставляя разделы только с уникальными именами:

```json
{
  id: number;
  createdAt?: string;
  updatedAt: string;
  name: string;
  thingId: number;
}
```

3. На основе полученных данных метод вызывает `getExistingSubjectByIds()`, чтобы извлечь идентификаторы предметов из разделов и проверить, какие из них уже существуют в базе данных, а также удалить дубликаты.
4. Метод использует `getExistingById()`, чтобы определить, какие разделы уже присутствуют в базе данных, используя идентификаторы, извлеченные из данных.
5. Создается массив `creatingSections`, в который сохраняется результат выполнения функции `getForCreate()` для определения разделов, которые необходимо создать.
	1. Сперва фильтруются данные на основе массива `existingSections`, что позволяет исключить существующие разделы.
	2. Для преобразования разделов в формат LessonSection и поиска существующих предметов вызывается функция `mapFields()`.
7. Создается массив `updatingSections`, в который сохраняется результат выполнения функции `getForUpdate()` для определения разделов, которые необходимо обновить.
	1. Сперва фильтруются данные на основе массива `existingSections`, при помощи функции `checkNeedUpdateAll` выявляются разделы, которые необходимо обновить.
	2. Для преобразования разделов в формат LessonSection и поиска существующих предметов вызывается функция `mapFields()`.
8. Полученные массивы `creatingSections` и `updatingSections` объединяются в один массив `sectionsToSave`, который будет использоваться для последующего сохранения в базе данных.
9. Метод подсчитывает количество разделов, которые будут созданы и обновлены, фильтруя разделы с пустыми идентификаторами.
10. Если массив `sectionsToSave` содержит разделы, метод выполняет их сохранение в базе данных с помощью `lessonSectionRepository.save()`. Перед началом и по завершении операции в лог выводится сообщение с количеством создаваемых и обновляемых разделов.

*Выходные данные:* Status: `200 OK`

Возвращает объект, содержащий количество созданных и обновленных разделов, а также их идентификаторы.

```json
{
  created: {
    count: number;
    id: number[] | string[];
  };
  updated: {
    count: number;
    id: number[] | string[];
  };
}
```

### Импорт SEO данных

*Входные данные:* -

*Функционал:*

Работа метода разделена на несколько этапов:

1. Метод инициирует GET-запрос к URL `seo/all?offset=0&limit=1000`, ожидая получить массив данных о SEO в формате `OldSeo`:

```json
{
  id: number;
  createdAt?: string;
  updatedAt: string;
  url: string;
  title: string;
  description: string;
  canonical: string;
}
```

2. Полученные данные обрабатываются с помощью метода `filterData()`, который удаляет дубликаты по полю `url`, оставляя только уникальные записи.
3. На основе идентификаторов из отфильтрованных данных метод использует `getExistingById()` для проверки, какие SEO-записи уже существуют в базе данных.
4. Создается массив `creatingSeo`, в который сохраняется результат выполнения функции `getForCreate()` для определения SEO-записей, которые необходимо создать.
	1. Сперва фильтруются данные на основе массива `existingSeo`, что позволяет исключить существующие SEO-записи.
	2. Для приведения SEO-записей к типу Seo и поиска существующих SEO-записей вызывается функция `mapFields()`.
7. Создается массив `updatingSeo`, в который сохраняется результат выполнения функции `getForUpdate()` для определения SEO-записей, которые необходимо обновить.
	1. Сперва фильтруются данные на основе массива `existingSeo`, при помощи функции `checkNeedUpdateAll` выявляются SEO-записи, которые необходимо обновить.
	2. Для приведения SEO-записей к типу Seo и поиска существующих SEO-записей вызывается функция `mapFields()`.
5. Метод подсчитывает количество SEO-записей, которые будут созданы и обновлены, фильтруя записи с пустыми идентификаторами.
6. Если массив `seoToSave` содержит записи, метод сохраняет их в базе данных с помощью `seoRepository.save()`. Перед началом и по завершении операции в лог выводится сообщение с количеством создаваемых и обновляемых SEO-записей.

*Выходные данные:* Status: `200 OK`

Возвращает объект, содержащий количество созданных и обновленных SEO-записей, а также их идентификаторы.

```json
{
  created: {
    count: number;
    id: number[] | string[];
  };
  updated: {
    count: number;
    id: number[] | string[];
  };
}
```

### Импорт видео

`GETimports/video/`

*Входные данные:* -

*Функционал:*

Работа метода разделена на несколько этапов:

1. Метод начинает с логирования сообщения о старте операции импорта видео.
2. Определяются пути к файлам `map.json` и `map.old.json`, содержащим данные о видео. Метод проверяет их наличие, и в случае отсутствия хотя бы одного из файлов выбрасывает исключение `InternalServerErrorException` с сообщением об ошибке "map file does not exist".
3. Метод считывает содержимое обоих файлов и парсит их в объекты JavaScript. Это позволяет извлечь данные о видео. Данные `map.json` сохраняются в массив `videos[]`, а `map.old.json` в массив `videosOld[]`.
4. На основе данных из `map.json` метод создает массив URL-адресов видео и сопоставляет их с идентификаторами Kinescope, используя map `urlToKinescopeId`. Это позволяет находить соответствия между URL и их идентификаторами.
5. Метод выполняет параллельный поиск загруженных видео в базе данных, используя методы `findByUrls` и `findByNames`. Это позволяет получить массивы существующих записей, которые будут обновлены.
6. После получения данных метод обновляет идентификаторы Kinescope для найденных загруженных видео, сопоставляя их с данными из `map.old.json`.
7. Метод объединяет обновленные записи и сохраняет их в базе данных с помощью `uploadRepository.save()`. Перед началом и по завершении операции в лог выводится сообщение с количеством сохраненных записей, что позволяет отслеживать изменения.

*Выходные данные:* Status: `200 OK`, boolean

### Получение идентификаторов сущности

`GET imports/get-all-ids/:entity/`

*Входные данные:*

- В URL запроса должен быть передан параметр:

```json
{
  entity: string
}
```

*Функционал:*

Работа метода разделена на несколько этапов:

1. На основе переданного параметра `entity`, метод использует `DataSource` для получения репозитория соответствующей сущности, что позволяет взаимодействовать с базой данных.
2. Метод формирует SQL-запрос с помощью `QueryBuilder`, который выбирает идентификаторы всех записей, у которых поле `name` не равно `NULL`.
3. Запрос выполняется, и метод возвращает массив идентификаторов, полученных из базы данных. Если записи не найдены, возвращается пустой массив.

*Выходные данные:* Status: `200 OK`

Возвращает массив строк, содержащий идентификаторы всех записей указанной сущности, у которых поле `name` не равно `NULL`. В случае отсутствия записей возвращается пустой массив.

### Обновление slug

`POST imports/update-entities-slug/`

*Входные данные:*

- В тело запроса должны быть переданы параметры (UpdateSlugDto):

```json
{
  entity: string;
  ids: string[];
}
```

*Функционал:*

Работа метода организована в несколько этапов:

1. Проходит по массиву переданных идентификаторов и для каждого из них выполняет следующие действия:
    - Если тип сущности равен Lesson, вызывает метод `updatingSlug`, передавая идентификатор, тип сущности, менеджер транзакции и массив `updatedData` для хранения сообщений об обновлениях.
2. В методе `updatingSlug` происходит поиск записи в базе данных по переданному идентификатору с помощью `manager.findOne()`.
3. Если запись найдена, метод генерирует новый slug с помощью сервиса `slugService`, вызывая `getUniqueSlug()`, и сравнивает его с текущим значением slug.
	-  Если новый slug совпадает с текущим, в массив `updatedData` добавляется сообщение о том, что обновление не требуется.
	-  В противном случае slug обновляется, запись сохраняется в базе данных с помощью `manager.save()`, и в массив добавляется сообщение об успешном обновлении.
4. Если запись не найдена, метод выбрасывает исключение `NotFoundException` с сообщением об ошибке "Запись не найдена", что приводит к завершению транзакции и откату всех изменений.
5. По завершении итерации по всем идентификаторам метод возвращает массив `updatedData`, содержащий информацию о каждом обновлении slug, включая сообщения об ошибках, если таковые возникли.

*Выходные данные:* Status: `200 OK`

Возвращает массив строк с информацией о каждом обновлении slug, включая сообщения об ошибках, если они произошли.

### Обновление разделов предметов 

`GET imports/update-sections-subjects/`

*Входные данные:* -

*Функционал:*

Работа метода организована в несколько этапов:

1. Метод начинает с логирования сообщения о старте операции импорта, что позволяет отслеживать выполнение в логах.
2. С помощью метода `getAllLessons()` получает все уроки из базы данных, включая связанные разделы и программы.
3. Метод вызывает `updateLessons()`, чтобы обновить разделы уроков в соответствии с их предметами. Здесь также проверяются существующие разделы и создаются новые, если это необходимо.
4. Все идентификаторы обновленных уроков собираются в массив `updatedId`.
5. После обновления разделов метод сохраняет все измененные уроки в базе данных с помощью `lessonRepository.save()`.
6. Метод логирует количество обновленных уроков до и после операции сохранения, предоставляя информацию о выполненной работе и результатах.

*Выходные данные:* Status: `200 OK`

Возвращает объект, содержащий количество созданных и обновленных уроков, а также их идентификаторы.

```json
{
  created: {
    count: number;
    id: number[] | string[];
  };
  updated: {
    count: number;
    id: number[] | string[];
  };
}
```

### Обновление количества попыток

`GET imports/attempts-numbers/`

*Входные данные:* -

*Функционал:*

Работа метода разделена на несколько этапов:

1. Метод получает массив `Task` из репозитория, который содержат количество попыток прохождения учебных материалов.
2. На основе полученных данных метод извлекает уникальные идентификаторы пользователей, которые делали попытки выполнить задачу, и сохраняет их в массив `taskUsers`.
3. Метод проходит по каждой задаче и для каждой попытки проверяет, принадлежит ли она пользователю из массива `taskUsers`. Если да, то обновляет номер попытки `attemptNumber` для каждой попытки, увеличивая его на один для данного пользователя.
4. После обработки всех задач метод сохраняет обновленные данные о задачах в базе данных с помощью `tasksRepository.save()`.

*Выходные данные:* Status: `200 OK`

Возвращает массив обновленных задач `tasks`, каждая из которых содержит обновленные номера попыток для пользователей.

```json
{
  id: string;
  createdAt: Date;
  subTitle?: string | null;
  description?: string | null;
  material: Material;
  attaches: Upload[];
  attempts: TaskAttempt[];
  bans: TaskBan[];
}
```

### Обновление индексов сортировки уроков

`GET imports/set-lesson-sorts/`

*Входные данные:* -

*Функционал:*

Работа метода разделена на несколько этапов:

1. Метод выполняет запрос к базе данных для извлечения всех программ вместе со связанными уроками.
2. Полученные уроки сортируются по полям `sortIndex` и `createdAt`, что позволяет установить правильный порядок для последующего обновления индексов сортировки.
3. Метод создает массив `lessonsToUpdate`, который будет использоваться для хранения уроков, требующих обновления индексов. Для каждой программы он перебирает связанные уроки и устанавливает новый индекс сортировки (`sortIndex`), начиная с 1 и увеличивая его для каждого урока.
5. Метод сохраняет все обновленные уроки из массива `lessonsToUpdate` в базе данных с помощью `lessonRepository.save()`.

*Выходные данные:* Status: `200 OK`. -

***

## Зависимости (импортируемые модули)

- HttpModule
- TypeOrmModule
- FfmpegModule
- UploadModule
- ProgramModule
- LessonModule

***

## Используемый стэк

- JavaScript
- NestJS
- TypeScript
- Node.js